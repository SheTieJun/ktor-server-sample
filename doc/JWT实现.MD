## JWTå®ç°  https://ktor.io/docs/jwt.html
```kotlin
implementation("io.ktor:ktor-server-auth-jvm")
implementation("io.ktor:ktor-server-auth-jwt-jvm")
```

## æ„å»ºtoken

```kotlin
   private fun makeToken(name: String): String = JWT.create()
        .withSubject(JwtConstant.jwtSubjectAuth)
        .withIssuer(JwtConstant.jwtDomain)
        .withAudience(JwtConstant.jwtAudience)
        .withClaim(Constant.USER_NAME, name)
        .withExpiresAt(getExpiration())
        .sign(Algorithm.HMAC256(JwtConstant.jwtSecret))
```

<aside>
ğŸ’¡ è¿™é‡Œæˆ‘ä»¬éœ€è¦åŒºåˆ†ä¸šåŠ¡è¯·æ±‚çš„Tokenå’ŒRefreshTokenï¼Œåœ¨è·å–çš„æ—¶å€™ä½ å¯ä»¥ä¸€äº›åŒºåˆ†,ç„¶åå†ä¸åŒè·¯ç”±å¤„ç†æ·»åŠ å¯¹åº”é™åˆ¶,æ¯”å¦‚æ™®é€štokenå’ŒrefreshToken
</aside>


### é…ç½®éªŒè¯

```kotlin
fun Application.configureSecurity() {
    install(Authentication) {
        jwt {
            realm = JwtConstant.jwtRealm
            verifier(
                JWT
                    .require(Algorithm.HMAC256(JwtConstant.jwtSecret))
                    .withSubject(JwtConstant.jwtSubjectAuth)
                    .withAudience(JwtConstant.jwtAudience)
                    .withIssuer(JwtConstant.jwtDomain)
                    .build()
            )
            validate { credential ->
                if (credential.payload.audience.contains(JwtConstant.jwtAudience)
                    && credential.payload.subject == JwtConstant.jwtSubjectAuth) {
                    JWTPrincipal(credential.payload)
                } else {
                    this.json403("JWTéªŒè¯å¤±è´¥")
                    null
                }
            }
        }

        jwt("refreshToken") {
            verifier(
                JWT
                    .require(Algorithm.HMAC256(JwtConstant.jwtSecret))
                    .withSubject(JwtConstant.jwtSubjectRefresh)
                    .withAudience(JwtConstant.jwtAudience)
                    .withIssuer(JwtConstant.jwtDomain)
                    .build()
            )
            validate { credential ->
                if (credential.payload.audience.contains(JwtConstant.jwtAudience)
                    && credential.payload.subject == JwtConstant.jwtSubjectRefresh) {
                    JWTPrincipal(credential.payload)
                } else {
                    this.json403("Invalid token")
                    null
                }
            }
        }
    }
}
```

### åº”ç”¨ï¼šéªŒè¯æ™®é€štokenå’ŒéªŒè¯refreshToken

```kotlin
//æ™®é€šè¯·æ±‚éªŒè¯token
authenticate {
        get("/userinfo") {
            call.jsonOk()
        }
}
//refreshToken éªŒè¯
authenticate("refreshToken") {
        get("/refresh") {
            val principal = call.payload
            if (principal != null) {
                val userName = (principal.claims[Constant.USER_NAME]?.asString()) ?: throw IllegalArgumentException("ç™»å½•å¤±æ•ˆè¯·é‡æ–°ç™»å½•")
                call.respond(RespondResult.success(AuthJwtKit.sign(userName)))
            } else {
                call.json403("ç™»å½•å¤±æ•ˆè¯·é‡æ–°ç™»å½•")
            }
        }
    }
```